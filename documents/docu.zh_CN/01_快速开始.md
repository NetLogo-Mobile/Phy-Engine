# 01 快速开始

本章用 3 个最小例子跑通 PE 的核心能力：模拟求解、数字时钟更新、Verilog（子集）综合到 PE 网表。

## 1) 最小模拟电路（OP）

核心 API：

- `phy_engine::circult`：电路求解上下文（`include/phy_engine/circuits/circuit.h`）
- `netlist::add_model/create_node/add_to_node`：搭网表（`include/phy_engine/netlist/operation.h`）

参考实现：`test/0004.solver/op.cpp`。

要点：

- 用 `add_model(nl, model)` 把器件塞进网表，返回 `model_base*`（可用 `->ptr` 访问具体模型接口）
- 用 `create_node(nl)` 创建节点（网络）
- 用 `add_to_node(nl, *model, pin_index, node)` 把器件某个引脚接到节点
- 地节点：`netlist::get_ground_node(nl)` 或 `nl.ground_node`
- `c.set_analyze_type(analyze_type::OP)` + `c.analyze()` 求解

## 2) 最小数字电路（`digital_clk()`）

数字模型通过节点上的 4 态值 `digital_node_statement_t` 传播。常见流程：

1. `c.analyze()`：先做一次分析，让电路完成 `prepare()`（内部会建立 MNA/数字更新表等）
2. 修改输入模型 attribute（通常 index=0）为 `H/L/X/Z`
3. 调用 `c.digital_clk()` 推进一个数字 tick，更新组合/时序逻辑

参考实现：`test/0006.digital/digital.cpp`。

## 3) Verilog（可综合子集）→ PE 网表

PE 内置一个“可综合的 Verilog 子集”前端：`include/phy_engine/verilog/digital/digital.h`，并提供把 elaboration 结果综合成 PE 数字 primitive 的接口：`include/phy_engine/verilog/digital/pe_synth.h`。

最小流程（参考 `test/0015.verilog_compile/pe_synth_and2.cpp`）：

1. `compile(src)`：编译得到模块集合与错误列表
2. `build_design()` / `find_module()` / `elaborate()`：得到顶层 instance
3. 在 PE `netlist` 中为每个 port 创建一个 `node_t*`（端口顺序必须和模块 port list 一致）
4. 为端口创建外部 IO 模型（如 `model::INPUT` / `model::OUTPUT`）并接到对应端口 node
5. `synthesize_to_pe_netlist(nl, top_inst, ports, &err, opt)`：把 Verilog 电路综合为 PE 数字 primitive 并加入网表
6. `c.analyze()` + 修改输入 + `c.digital_clk()`：驱动仿真

更大规模例子可参考：`test/0021.fp16_fpu/fp16_fpu_pe_sim_and_export.cpp`（包含 `\`include` 文件解析、端口位展开、以及导出到 PhysicsLab `.sav`）。

